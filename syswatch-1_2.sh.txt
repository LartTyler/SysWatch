#!/bin/bash

# Configuration:
#
# INTERFACE:
#       This is the interface that your traffic goes through (probably eth0?)
INTERFACE="eth0"

# MEM_THRESHOLD:
#       This is the memory threshold, in percent of total system RAM. Once the current usage exceeds the
#       threshold, the program will start to spit out debug information to be emailed.
#       NOTE: MUST have a single decimal place at the end.
MEM_THRESHOLD=75.0

# DRP_RX_THRESHOLD:
#       This is the maximum number of packets received that WE dropped allowed on the interface before we start to notify. Once
#       this number of drops is passed, we start emailing data.
DRP_RX_THRESHOLD=10

# DRP_TX_THRESHOLD:
#       This is the maximum number of packets transmitted that WE dropped allowed on the interface before we start to notify. Once
#       this number of drops is passed, we start emailing data. This value is in kilobytes.
DRP_TX_THRESHOLD=10

# MAIL_TARGET:
#       What email address to send the update to. If left blank, this script will log to ~/.syswatch.
MAIL_TARGET=""

# LOG_SIZE_LIMIT:
#       The maximum size (in megabytes) the log file can reach before it needs to be rolled. The old log file will be moved to
#       ~/.syswatch.old, and loggin will continue in ~/.syswatch
LOG_SIZE_LIMIT=100

# SUBJECT:
#       SUBJECT is the default subject line for any error mails. Normall, a subject line on an error mail would look something like
#       "Memory error - TX error". By adding a string to SUBJECT here, you can add a prefix before the error reporting, for example,
#       if you set SUBJECT to "Hurricane Log", your new error subject would look like "Hurricane Log - Memory error - TX error"
SUBJECT=""

# ERROR:
#       If ERROR is set to 1 during the scripts run, it lets the script know to send an email containing debug info. However,
#       if you set ERROR to 1 here, it will ALWAYS email debug information.
ERROR=0

#####

CURR_MEM=`ps aux | awk '{sum +=$4}; END {print sum}'`
# BASh can't handle decimal operations, so pipe the logic operation to bc, which will output 1 (true) or 0 (false)
COMPARE=`echo "$CURR_MEM > $MEM_THRESHOLD" | bc`
if [ $COMPARE -eq 1 ]; then
        MEM_MSG="Memory is above threshold. Currently at $CURR_MEM%."
        SUBJECT="$SUBJECT - Memory error"
        $ERROR=1
else
        MEM_MSG="Memory is safe (below threshold). Threshold is set at $MEM_THRESHOLD%, we are running at $CURR_MEM%."
        SUBJECT=""
fi

CURR_DRP_RX=`/sbin/ifconfig $INTERFACE | grep "RX packets:" | awk '{split($4,rx,":"); print rx[2]}'`
if [ $COMPARE -eq 1 ]; then
        RX_MSG="We have passed our max allowed received dropped packets. Our threshold is $DRP_RX_THRESHOLD, we have dropped $CURR_DRP_RX."
        $SUBJECT="$SUBJECT - RX error"
        $ERROR=1
else
        RX_MSG="We have NOT passed our received dropped packets threshold. The threshold is set to $DRP_RX_THRESHOLD, we have dropped $CURR_DRP_RX."
fi

CURR_DRP_TX=`/sbin/ifconfig $INTERFACE | grep "TX packets:" | awk '{split($4,tx,":"); print tx[2]}'`
if [ $CURR_DRP_TX -gt $DRP_TX_THRESHOLD ]; then
        TX_MSG="We have passed our max allowed transmitted dropped packets. Our threshold is $DRP_TX_THRESHOLD, we have dropped $CURR_DRP_TX."
        $SUBJECT="$SUBJECT - TX error"
        $ERROR=1
else
        TX_MSG="We have NOT passed our transmitted dropped packets threshold. The threshold is set to $DRP_TX_THRESHOLD, we have dropped $CURR_DRP_TX."
fi

LOGTIME=`date`
FULL_MSG=`echo -e "[$LOGTIME]\t$MEM_MSG\n[$LOGTIME]\t$RX_MSG\n[$LOGTIME]\t$TX_MSG\n"`
LOGSIZE=`du -sk ~/.syswatch | awk '{print $1}'`

# Convert LOG_SIZE_LIMIT to kilobytes (since du -sk outputs in kilobytes)
TRUE_LIM=`echo "$LOG_SIZE_LIMIT*1024" | bc`
if [ $LOGSIZE -gt $TRUE_LIM ]; then
        if [ -f ~/.syswatch.old ]; then
                rm -f ~/.syswatch.old
        fi
        mv ~/.syswatch ~/.syswatch.old
fi

touch ~/.syswatch
echo -e "$FULL_MSG" >> ~/.syswatch

# Only mail the gathered info if we detect an error. Regardless, we will still output debug info to ~/.syswatch
if [ $ERROR -eq 1 ]; then
        if [ $MAIL_TARGET != "" ]; then
                FULL_MSG=`echo -e "Error: $SUBJECT\nTime: $LOGTIME\n\n$MEM_MSG\n$RX_MSG\n$TX_MSG\n\n\nThis error email generated by syswatch."`
                echo -e "$FULL_MSG" > ~/.syswatch_lastMail
                mail -s "$SUBJECT" "$MAIL_TARGET" < ~/.syswatch_lastMail
        fi
fi
